# Test PostgreSQL Database Operations
# This file demonstrates database query capabilities in Robogo

testcase: "PostgreSQL Database Test"
description: "Test file to demonstrate PostgreSQL database operations"

variables:
  secrets:
    db_password:
      file: "secret.txt"
      mask_output: false
  vars:
    db_host: "localhost"
    db_port: "5432"
    db_name: "robogo_testdb"
    db_user: "robogo_testuser"
    # Dynamic variables constructed from other variables
    db_connection_string: "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable"

steps:
  - name: "Log password"
    action: log
    args: ["Password is: ${db_password}"]
  - name: "Log start"
    action: log
    args: ["Starting postgres test with dedicated test database"]

  - name: "Log connection string (masked)"
    action: log
    args: ["Using database: ${db_connection_string} with user: ${db_connection_string}"]

  # Test database connection
  - name: "Test database connection"
    action: postgres
    args: ["connect", "${db_connection_string}"]
    result: connection_result

  - name: "Log connection result"
    action: log
    args: ["Connection result: ${connection_result}"]

  # Create a test table with unique name for parallel testing
  - name: "Get timestamp for table isolation"
    action: get_time
    args: ["unix_ms"]
    result: table_timestamp

  - name: "Create unique table name"
    action: concat
    args: ["test_users_", "${table_timestamp}"]
    result: unique_table_name

  - name: "Log unique table name"
    action: log
    args: ["Unique table name: ${unique_table_name}"]

  - name: "Create test table"
    action: postgres
    args: ["execute", "${db_connection_string}", "CREATE TABLE IF NOT EXISTS ${unique_table_name} (id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)"]
    result: create_table_result

  - name: "Log table creation result"
    action: log
    args: ["Table creation result: ${create_table_result}"]

  # Insert test data
  - name: "Insert test user 1"
    action: postgres
    args: ["execute", "${db_connection_string}", "INSERT INTO ${unique_table_name} (name, email) VALUES ($1, $2)", ["John Doe", "john@example.com"]]
    result: insert_result_1

  - name: "Insert test user 2"
    action: postgres
    args: ["execute", "${db_connection_string}", "INSERT INTO ${unique_table_name} (name, email) VALUES ($1, $2)", ["Jane Smith", "jane@example.com"]]
    result: insert_result_2

  - name: "Log insert results"
    action: log
    args: ["Insert results: ${insert_result_1}, ${insert_result_2}"]

  # Query all users
  - name: "Query all users"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT id, name, email, created_at FROM ${unique_table_name} ORDER BY id"]
    result: query_result

  - name: "Log query result"
    action: log
    args: ["Query result: ${query_result}"]

  # Query with parameter
  - name: "Query user by name"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT id, name, email FROM ${unique_table_name} WHERE name = $1", ["John Doe"]]
    result: query_by_name_result

  - name: "Log query by name result"
    action: log
    args: ["Query by name result: ${query_by_name_result}"]

  # Update user
  - name: "Update user email"
    action: postgres
    args: ["execute", "${db_connection_string}", "UPDATE ${unique_table_name} SET email = $1 WHERE name = $2", ["john.updated@example.com", "John Doe"]]
    result: update_result

  - name: "Log update result"
    action: log
    args: ["Update result: ${update_result}"]

  # Verify update
  - name: "Verify updated email"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT email FROM ${unique_table_name} WHERE name = $1", ["John Doe"]]
    result: verify_update_result

  - name: "Log verification result"
    action: log
    args: ["Verification result: ${verify_update_result}"]

  # Test additional queries
  - name: "Count total users"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT COUNT(*) as total_users FROM ${unique_table_name}"]
    result: count_result

  - name: "Log user count"
    action: log
    args: ["Total users: ${count_result}"]

  # Delete test data
  - name: "Delete test users"
    action: postgres
    args: ["execute", "${db_connection_string}", "DELETE FROM ${unique_table_name} WHERE name IN ($1, $2)", ["John Doe", "Jane Smith"]]
    result: delete_result

  - name: "Log delete result"
    action: log
    args: ["Delete result: ${delete_result}"]

  # Verify deletion
  - name: "Verify deletion"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT COUNT(*) as user_count FROM ${unique_table_name}"]
    result: count_result

  - name: "Log count result"
    action: log
    args: ["Count result: ${count_result}"]

  # Clean up test table
  - name: "Drop test table"
    action: postgres
    args: ["execute", "${db_connection_string}", "DROP TABLE IF EXISTS ${unique_table_name}"]
    result: drop_table_result

  - name: "Log table cleanup"
    action: log
    args: ["Table cleanup result: ${drop_table_result}"]

  # Close database connection
  - name: "Close database connection"
    action: postgres
    args: ["close", "${db_connection_string}"]
    result: close_result

  - name: "Log close result"
    action: log
    args: ["Close result: ${close_result}"]

  # Final assertion
  - name: "Assert test completed"
    action: log
    args: ["ðŸŽ‰ PostgreSQL database test completed successfully!"]
