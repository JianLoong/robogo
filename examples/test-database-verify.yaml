testcase: "TC-DATABASE-VERIFY"
description: "Database test with data verification"

variables:
  vars:
    db_url: "postgres://robogo_testuser:robogo_testpass@localhost:5432/robogo_testdb?sslmode=disable"
    user_name: "Alice Smith"
    user_email: "alice@test.com"
    user_age: "30"

steps:
  # Setup test table
  - name: "Create test table with multiple columns"
    action: postgres
    args: ["execute", "${db_url}", "CREATE TABLE IF NOT EXISTS test_users (id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100), age INTEGER, created_at TIMESTAMP DEFAULT NOW())"]

  # Insert test data
  - name: "Insert user with multiple fields"
    action: postgres
    args: ["execute", "${db_url}", "INSERT INTO test_users (name, email, age) VALUES ('${user_name}', '${user_email}', ${user_age}) RETURNING id"]
    result: "insert_result"

  # Query back the inserted data
  - name: "Query inserted user by email"
    action: postgres
    args: ["query", "${db_url}", "SELECT id, name, email, age FROM test_users WHERE email = '${user_email}'"]
    result: "user_data"

  # Store the first row data for verification
  - name: "Store user ID for later use"
    action: variable
    args: ["user_id", "${user_data.rows[0][0]}"]

  - name: "Store retrieved name"
    action: variable
    args: ["retrieved_name", "${user_data.rows[0][1]}"]

  - name: "Store retrieved email"
    action: variable
    args: ["retrieved_email", "${user_data.rows[0][2]}"]

  - name: "Store retrieved age"
    action: variable
    args: ["retrieved_age", "${user_data.rows[0][3]}"]

  # Verify all the data matches what we inserted
  - name: "Verify name matches"
    action: assert
    args: ["${retrieved_name}", "==", "${user_name}", "Name should match inserted value"]

  - name: "Verify email matches"
    action: assert
    args: ["${retrieved_email}", "==", "${user_email}", "Email should match inserted value"]

  - name: "Verify age matches"
    action: assert
    args: ["${retrieved_age}", "==", "${user_age}", "Age should match inserted value"]

  - name: "Verify user ID is valid"
    action: assert
    args: ["${user_id}", "!=", "", "User ID should not be empty"]

  # Test UPDATE operation
  - name: "Update user age"
    action: postgres
    args: ["execute", "${db_url}", "UPDATE test_users SET age = 31 WHERE id = ${user_id}"]
    result: "update_result"

  - name: "Verify update affected one row"
    action: assert
    args: ["${update_result.rows_affected}", "==", "1", "Update should affect exactly 1 row"]

  # Verify the update worked
  - name: "Query updated user"
    action: postgres
    args: ["query", "${db_url}", "SELECT age FROM test_users WHERE id = ${user_id}"]
    result: "updated_data"

  - name: "Store updated age"
    action: variable
    args: ["new_age", "${updated_data.rows[0][0]}"]

  - name: "Verify age was updated"
    action: assert
    args: ["${new_age}", "==", "31", "Age should be updated to 31"]

  # Test aggregate functions
  - name: "Count users"
    action: postgres
    args: ["query", "${db_url}", "SELECT COUNT(*) FROM test_users"]
    result: "count_data"

  - name: "Store user count"
    action: variable
    args: ["total_users", "${count_data.rows[0][0]}"]

  - name: "Verify we have at least our test user"
    action: assert
    args: ["${total_users}", "!=", "0", "Should have at least 1 user"]

  # Cleanup
  - name: "Delete test user"
    action: postgres
    args: ["execute", "${db_url}", "DELETE FROM test_users WHERE id = ${user_id}"]

  - name: "Log successful completion"
    action: log
    args: ["Database verification test completed successfully!"]