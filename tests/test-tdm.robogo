# Test Data Management (TDM) Comprehensive Test
# This file demonstrates the complete TDM functionality in Robogo

testcase: "TDM Comprehensive Test"
description: "Test file to demonstrate Test Data Management features including data sets, environments, validation, and data lifecycle"

# Environment configurations
environments:
  - name: "development"
    description: "Development environment configuration"
    variables:
      api_base_url: "https://dev-api.example.com"
      db_host: "dev-db.example.com"
      timeout: 30
    data_sets: ["dev_users", "dev_products"]
    overrides:
      log_level: "debug"
      retry_count: 3

  - name: "staging"
    description: "Staging environment configuration"
    variables:
      api_base_url: "https://staging-api.example.com"
      db_host: "staging-db.example.com"
      timeout: 60
    data_sets: ["staging_users", "staging_products"]
    overrides:
      log_level: "info"
      retry_count: 5

# Test Data Management configuration
data_management:
  environment: "development"
  isolation: true
  cleanup: true
  
  # Data sets for testing
  data_sets:
    - name: "dev_users"
      description: "Development user data set"
      version: "1.0"
      environment: "development"
      data:
        admin_user:
          username: "admin"
          email: "admin@example.com"
          role: "administrator"
          permissions: ["read", "write", "delete"]
        test_user:
          username: "testuser"
          email: "test@example.com"
          role: "user"
          permissions: ["read"]
        guest_user:
          username: "guest"
          email: "guest@example.com"
          role: "guest"
          permissions: ["read"]
      schema:
        username: "string"
        email: "email"
        role: "string"
        permissions: "array"
      required: ["username", "email", "role"]
      unique: ["username", "email"]
      relations:
        - type: "foreign_key"
          field: "role"
          reference: "roles.name"
          required: true

    - name: "dev_products"
      description: "Development product data set"
      version: "1.0"
      environment: "development"
      data:
        product_1:
          id: "PROD-001"
          name: "Test Product 1"
          price: 99.99
          category: "electronics"
          in_stock: true
          tags: ["new", "featured"]
        product_2:
          id: "PROD-002"
          name: "Test Product 2"
          price: 149.99
          category: "books"
          in_stock: false
          tags: ["bestseller"]
      schema:
        id: "string"
        name: "string"
        price: "number"
        category: "string"
        in_stock: "boolean"
        tags: "array"
      required: ["id", "name", "price"]
      unique: ["id"]

  # Data validation rules
  validation:
    - name: "email_format_validation"
      type: "format"
      field: "dev_users.admin_user.email"
      rule: "email"
      message: "Admin user email must be in valid format"
      severity: "error"
      continue_on_failure: false

    - name: "price_range_validation"
      type: "range"
      field: "dev_products.product_1.price"
      rule:
        min: 0
        max: 1000
      message: "Product price must be between 0 and 1000"
      severity: "error"
      continue_on_failure: false

    - name: "username_length_validation"
      type: "length"
      field: "dev_users.test_user.username"
      rule:
        min: 3
        max: 50
      message: "Username must be between 3 and 50 characters"
      severity: "warning"
      continue_on_failure: true

    - name: "required_field_validation"
      type: "required"
      field: "dev_users.admin_user.role"
      rule: true
      message: "User role is required"
      severity: "error"
      continue_on_failure: false

  # TDM Setup - runs before test execution
  setup:
    - name: "Initialize test database"
      action: log
      args: ["Setting up test database for TDM test"]
    
      # Build connection string with secrets
    - name: "Build connection string"
      action: concat
      args: ["postgres://", "${db_user}", ":", "${db_password}", "@", "${db_host}", ":", "${db_port}", "/", "${db_name}", "?sslmode=disable"]
      result: db_connection_string
      verbose: false
    
    - name: "Test database connection"
      action: postgres
      args: ["connect", "${db_connection_string}"]
      result: setup_connection_result
      continue_on_failure: false
    
    - name: "Create test tables"
      action: postgres
      args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "CREATE TABLE IF NOT EXISTS tdm_test_users (id SERIAL PRIMARY KEY, username VARCHAR(50), email VARCHAR(100), role VARCHAR(20))"]
      continue_on_failure: true
    
    - name: "Insert test data"
      action: postgres
      args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "INSERT INTO tdm_test_users (username, email, role) VALUES ($1, $2, $3)", ["${dev_users.admin_user.username}", "${dev_users.admin_user.email}", "${dev_users.admin_user.role}"]]
      continue_on_failure: true

  # TDM Teardown - runs after test execution
  teardown:
    - name: "Clean up test data"
      action: log
      args: ["Cleaning up test data"]
    
    - name: "Delete test users"
      action: postgres
      args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "DELETE FROM tdm_test_users WHERE username IN ($1, $2, $3)", ["${dev_users.admin_user.username}", "${dev_users.test_user.username}", "${dev_users.guest_user.username}"]]
      continue_on_failure: true
    
    - name: "Drop test tables"
      action: postgres
      args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "DROP TABLE IF EXISTS tdm_test_users"]
      continue_on_failure: true
    
    - name: "Drop TDM tables"
      action: postgres
      args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "DROP TABLE IF EXISTS tdm_users"]
      continue_on_failure: true
    
    - name: "Drop TDM products table"
      action: postgres
      args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "DROP TABLE IF EXISTS tdm_products"]
      continue_on_failure: true
    
    - name: "Close database connection"
      action: postgres
      args: ["close", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable"]
      result: teardown_close_result
      continue_on_failure: true

# Regular variables
variables:
  vars:
    test_name: "TDM Comprehensive Test"
    test_version: "1.0"
    max_retries: 3
    db_host: "192.168.0.174"
    db_port: "5432"
    db_name: "postgres"
    db_user: "postgres"
  secrets:
    db_password:
      file: "secret.txt"
      mask_output: true

# Test execution steps
steps:
  # Test environment loading
  - name: "Log environment information"
    action: log
    args: ["Running test in environment: ${env.development.api_base_url}"]
  
  - name: "Log data set information"
    action: log
    args: ["Loaded data sets: dev_users (${dev_users.admin_user.username}), dev_products (${dev_products.product_1.name})"]

  # Build database connection string
  - name: "Build connection string"
    action: log
    args: ["Building database connection string for TDM test"]

  - name: "Build connection string"
    action: concat
    args: ["postgres://", "${db_user}", ":", "${db_password}", "@", "${db_host}", ":", "${db_port}", "/", "${db_name}", "?sslmode=disable"]
    result: db_connection_string

  # Test database connection
  # - name: "Test database connection"
  #   action: postgres
  #   args: ["connect", "${db_connection_string}"]
  #   result: connection_result

  - name: "Log connection result"
    action: log
    args: ["Database connection result: ${connection_result}"]

  # Create TDM test tables
  - name: "Create TDM users table"
    action: postgres
    args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "CREATE TABLE IF NOT EXISTS tdm_users (id SERIAL PRIMARY KEY, username VARCHAR(100), email VARCHAR(100), role VARCHAR(50), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)"]
    result: create_users_table_result

  - name: "Create TDM products table"
    action: postgres
    args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "CREATE TABLE IF NOT EXISTS tdm_products (id SERIAL PRIMARY KEY, product_id VARCHAR(50), name VARCHAR(200), price DECIMAL(10,2), category VARCHAR(100), in_stock BOOLEAN, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)"]
    result: create_products_table_result

  # Insert TDM test data
  - name: "Insert admin user"
    action: postgres
    args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "INSERT INTO tdm_users (username, email, role) VALUES ($1, $2, $3)", ["${dev_users.admin_user.username}", "${dev_users.admin_user.email}", "${dev_users.admin_user.role}"]]
    result: insert_admin_result

  - name: "Insert test user"
    action: postgres
    args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "INSERT INTO tdm_users (username, email, role) VALUES ($1, $2, $3)", ["${dev_users.test_user.username}", "${dev_users.test_user.email}", "${dev_users.test_user.role}"]]
    result: insert_test_user_result

  - name: "Insert product 1"
    action: postgres
    args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "INSERT INTO tdm_products (product_id, name, price, category, in_stock) VALUES ($1, $2, $3, $4, $5)", ["${dev_products.product_1.id}", "${dev_products.product_1.name}", "${dev_products.product_1.price}", "${dev_products.product_1.category}", "${dev_products.product_1.in_stock}"]]
    result: insert_product1_result

  - name: "Insert product 2"
    action: postgres
    args: ["execute", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "INSERT INTO tdm_products (product_id, name, price, category, in_stock) VALUES ($1, $2, $3, $4, $5)", ["${dev_products.product_2.id}", "${dev_products.product_2.name}", "${dev_products.product_2.price}", "${dev_products.product_2.category}", "${dev_products.product_2.in_stock}"]]
    result: insert_product2_result

  # Query TDM test data
  - name: "Query all users"
    action: postgres
    args: ["query", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "SELECT username, email, role FROM tdm_users ORDER BY username"]
    result: query_users_result

  - name: "Query all products"
    action: postgres
    args: ["query", "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable", "SELECT product_id, name, price, category, in_stock FROM tdm_products ORDER BY product_id"]
    result: query_products_result

  - name: "Log query results"
    action: log
    args: ["Users query result: ${query_users_result}"]
  
  - name: "Log products query"
    action: log
    args: ["Products query result: ${query_products_result}"]

  # Test data-driven operations
  - name: "Test data-driven user creation"
    for:
      condition: "1..3"
      steps:
        - name: "Create user with generated data"
          action: variable
          args: ["set", "current_user_name", "user_${iteration}"]
          result: user_name_result
        
        - name: "Create user email"
          action: variable
          args: ["set", "current_user_email", "${current_user_name}@example.com"]
          result: user_email_result
        
        - name: "Log user creation"
          action: log
          args: ["Creating user: ${current_user_name} with email: ${current_user_email}"]

  # Test data assertions
  - name: "Assert admin user exists"
    action: assert
    args: ["${dev_users.admin_user.username}", "==", "admin", "Admin user should exist"]
  
  - name: "Assert product price is valid"
    action: assert
    args: ["${dev_products.product_1.price}", ">", "0", "Product price should be positive"]
  
  - name: "Assert user email format"
    action: assert
    args: ["${dev_users.admin_user.email}", "contains", "@", "User email should contain @ symbol"]

  # Test data isolation
  - name: "Create isolated test data"
    action: get_time
    args: ["unix_ms"]
    result: isolation_timestamp
  
  - name: "Create unique test identifier"
    action: variable
    args: ["set", "test_identifier", "test_${isolation_timestamp}"]
    result: identifier_result
  
  - name: "Log isolation test"
    action: log
    args: ["Test identifier for isolation: ${test_identifier}"]

  # Test data cleanup verification
  - name: "Verify cleanup preparation"
    action: log
    args: ["Preparing for data cleanup - test data will be removed after execution"]

  # Final validation
  - name: "Final data validation"
    action: assert
    args: ["${dev_users.admin_user.role}", "==", "administrator", "Admin role should be administrator"]
    continue_on_failure: true
  
  - name: "Final product validation"
    action: assert
    args: ["${dev_products.product_1.in_stock}", "==", "true", "Product should be in stock"]
    continue_on_failure: true

  # Success message
  - name: "TDM test completed"
    action: log
    args: ["🎉 TDM comprehensive test completed successfully!"]

# This test demonstrates:
# - Environment-specific configurations
# - Structured data sets with validation
# - Data lifecycle management (setup/teardown)
# - Data generation and validation
# - Data-driven testing
# - Data isolation and cleanup
# - Comprehensive validation rules
# - Integration with existing Robogo features 