# Test PostgreSQL Database Operations
# This file demonstrates database query capabilities in Robogo

testcase: "PostgreSQL Database Test"
description: "Test file to demonstrate PostgreSQL database operations"

variables:
  vars:
    db_host: "192.168.0.174"
    db_port: "5432"
    db_name: "robogo_testdb"
    db_user: "robogo_testuser"
  secrets:
    db_password:
        file: "secret.txt"
        mask_output: false

steps:

  - name: "Log start"
    action: log
    args: ["Starting postgres test with dedicated test database"]
  # Build connection string with secrets
  - name: "Build connection string"
    action: concat
    args: ["postgres://", "${db_user}", ":", "${db_password}", "@", "${db_host}", ":", "${db_port}", "/", "${db_name}", "?sslmode=disable"]
    result: db_connection_string

  - name: "Log connection string (masked)"
    action: log
    args: ["Using database: ${db_name} with user: ${db_user}"]

  # Test database connection
  - name: "Test database connection"
    action: postgres
    args: ["connect", "${db_connection_string}"]
    result: connection_result


  - name: "Log connection result"
    action: log
    args: ["Connection result: ${connection_result}"]

  # Create a test table with unique name for parallel testing
  - name: "Get timestamp for table isolation"
    action: get_time
    args: ["unix_ms"]
    result: table_timestamp
  
  - name: "Create unique table name"
    action: variable
    args: ["set", "unique_table_name", "test_users_${table_timestamp}"]
    result: table_name_result

  - name: "Create test table"
    action: postgres
    args: ["execute", "${db_connection_string}", "CREATE TABLE IF NOT EXISTS ${unique_table_name} (id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)"]
    result: create_table_result

  - name: "Log table creation result"
    action: log
    args: ["Table creation result: ${create_table_result}"]

  # Insert test data
  - name: "Insert test user 1"
    action: postgres
    args: ["execute", "${db_connection_string}", "INSERT INTO ${unique_table_name} (name, email) VALUES ($1, $2)", ["John Doe", "john@example.com"]]
    result: insert_result_1

  - name: "Insert test user 2"
    action: postgres
    args: ["execute", "${db_connection_string}", "INSERT INTO ${unique_table_name} (name, email) VALUES ($1, $2)", ["Jane Smith", "jane@example.com"]]
    result: insert_result_2

  - name: "Log insert results"
    action: log
    args: ["Insert results: ${insert_result_1}, ${insert_result_2}"]

  # Query all users
  - name: "Query all users"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT id, name, email, created_at FROM ${unique_table_name} ORDER BY id"]
    result: query_result

  - name: "Log query result"
    action: log
    args: ["Query result: ${query_result}"]

  # Query with parameter
  - name: "Query user by name"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT id, name, email FROM ${unique_table_name} WHERE name = $1", ["John Doe"]]
    result: query_by_name_result

  - name: "Log query by name result"
    action: log
    args: ["Query by name result: ${query_by_name_result}"]

  # Update user
  - name: "Update user email"
    action: postgres
    args: ["execute", "${db_connection_string}", "UPDATE ${unique_table_name} SET email = $1 WHERE name = $2", ["john.updated@example.com", "John Doe"]]
    result: update_result

  - name: "Log update result"
    action: log
    args: ["Update result: ${update_result}"]

  # Verify update
  - name: "Verify updated email"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT email FROM ${unique_table_name} WHERE name = $1", ["John Doe"]]
    result: verify_update_result

  - name: "Log verification result"
    action: log
    args: ["Verification result: ${verify_update_result}"]

  # Test additional queries
  - name: "Count total users"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT COUNT(*) as total_users FROM ${unique_table_name}"]
    result: count_result

  - name: "Log user count"
    action: log
    args: ["Total users: ${count_result}"]

  # Delete test data
  - name: "Delete test users"
    action: postgres
    args: ["execute", "${db_connection_string}", "DELETE FROM ${unique_table_name} WHERE name IN ($1, $2)", ["John Doe", "Jane Smith"]]
    result: delete_result

  - name: "Log delete result"
    action: log
    args: ["Delete result: ${delete_result}"]

  # Verify deletion
  - name: "Verify deletion"
    action: postgres
    args: ["query", "${db_connection_string}", "SELECT COUNT(*) as user_count FROM ${unique_table_name}"]
    result: count_result

  - name: "Log count result"
    action: log
    args: ["Count result: ${count_result}"]

  # Clean up test table
  - name: "Drop test table"
    action: postgres
    args: ["execute", "${db_connection_string}", "DROP TABLE IF EXISTS ${unique_table_name}"]
    result: drop_table_result

  - name: "Log table cleanup"
    action: log
    args: ["Table cleanup result: ${drop_table_result}"]

  # Close database connection
  - name: "Close database connection"
    action: postgres
    args: ["close", "${db_connection_string}"]
    result: close_result

  - name: "Log close result"
    action: log
    args: ["Close result: ${close_result}"]

  # Final assertion
  - name: "Assert test completed"
    action: log
    args: ["ðŸŽ‰ PostgreSQL database test completed successfully!"]

# Available PostgreSQL operations:
# - connect: Test database connection
# - query: Execute SELECT queries and return results
# - execute: Execute data modification statements (INSERT, UPDATE, DELETE)
# - close: Close database connection
# - batch: Execute multiple operations in parallel (advanced feature)
#
# Connection string format:
# postgres://username:password@host:port/database?sslmode=disable
#
# Query result format (JSON):
# {
#   "query": "SELECT * FROM users",
#   "columns": ["id", "name", "email"],
#   "rows": [["1", "John", "john@example.com"]],
#   "duration": "1.234ms",
#   "metadata": {"row_count": 1}
# }
#
# Statement result format (JSON):
# {
#   "query": "INSERT INTO users (name) VALUES ($1)",
#   "rows_affected": 1,
#   "last_insert_id": 0,
#   "duration": "1.234ms",
#   "metadata": {"operation": "INSERT"}
# }
#
# Note: This test uses secrets from secret.txt for database credentials
# Database setup for parallel testing:
# - Database: robogo_testdb (dedicated test database)
# - User: robogo_testuser (dedicated test user with limited permissions)
# - Tables: Created with unique timestamps for parallel test isolation 
